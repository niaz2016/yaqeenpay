Plan: consolidate withdrawal pages and standardize terminology to "user"
I'll implement this in safe, incremental steps. Below is the documented plan (contract, exact steps, file targets, edge cases, QA gates, and rollout notes) so we can proceed with minimal risk.

Contract (success criteria)
Inputs: current repo where SellerWithdrawalsPage was moved into WithdrawalsPage.tsx, and the codebase uses both "buyer" and "seller".
Outputs:
A single, canonical WithdrawalsPage component in WithdrawalsPage.tsx (exported/used consistently).
Code-level terminology uses user instead of buyer/seller (types, props, services, components, API DTOs), while preserving necessary UX labels where context matters.
No broken imports, TypeScript or .NET compile errors, and tests pass (or any failures fixed).
Backward-compatible API/DB behavior (no breaking payload name changes without migration/deprecation).
Error modes:
Type errors from incomplete renames.
API contract breakages for external consumers.
DB migrations that accidentally break production data (avoid unless necessary).
High-level plan (phased, safe rollout)
Phase A — Inventory & plan (this message)

Produce exhaustive list of candidate files for changes.
Decide scope for immediate changes (frontend first) vs. cautious changes (backend, DB).
Phase B — Frontend consolidation and rename

Make WithdrawalsPage the canonical page:
Rename component inside WithdrawalsPage.tsx from SellerWithdrawalsPage → WithdrawalsPage.
Update any index.ts re-exports if needed (keep backwards-compatible exports while switching to canonical name).
Update App.tsx routes to use a single route (or point both /withdrawals and /seller/withdrawals to the same component) then eventually remove the redundant route.
Replace terminology in frontend code:
Create new src/types/user.ts (or consolidate) and replace imports from ../types/seller → ../types/user.
Move or alias components/seller/* → components/user/* (or add wrapper files exporting from new names).
Update services and selectors: sellerServiceSelector → userServiceSelector (keeping old symbol as a thin deprecated alias for now).
Update UI copy where appropriate (use "User" in code and prefer contextual UX labels like "Buyer / Seller" only where helpful for end user clarity).
Run frontend type checks (tsc), lint + build. Fix any errors.
Phase C — Backend changes (cautious)

Inventory all Buyer/Seller identifiers in DTOs, models, controllers, services, and migrations.
Prefer code-level renames with serialization mapping:
In C#, rename properties to use UserXxx names in code, but annotate with [JsonPropertyName("buyerId")] or similar to keep JSON payload stable until clients migrate.
If DB column names must change, prepare an explicit migration and plan. If possible, avoid renaming DB columns in this pass.
Update API docs and add deprecation notes for old buyer/seller fields if you intend to change JSON keys later.
Run dotnet build and tests, fix failures.
Phase D — Tests, docs, cleanup

Update unit/integration tests across frontend and backend.
Add at least one test verifying a single account can act as both buyer and seller (withdrawal flows).
Update developer docs and CHANGELOG explaining the renaming and migration plan.
Remove old aliases (e.g., sellerServiceSelector) after a deprecation window.
Phase E — PR & rollout

Create small, focused commits per area (frontend rename, frontend cleanup, backend DTO mapping).
Open PR with an exhaustive file list, migration notes, QA instructions.
Merge after CI + local smoke tests pass.
Concrete file/area targets (first pass)
I ran an initial search and found immediate frontend targets. These will be updated during Phase B:

Frontend page(s)

WithdrawalsPage.tsx — currently houses SellerWithdrawalsPage (needs canonical rename).
index.ts — re-exports ../WithdrawalsPage.
App.tsx — imports and route entries for /withdrawals and /seller/withdrawals.
WithdrawalRequestForm.tsx — used by the page; consider moving or aliasing to components/user.
sellerServiceSelector.ts and related services/*seller* files — migrate to user naming or add aliases.
seller.ts — create/replace with src/types/user.ts.
wallet.ts — already used here; ensure it stays consistent.
Frontend docs

PHASE4_COMPLETE.md — references to "SellerWithdrawalsPage".
Backend (inventory to be collected)

Search for Buyer/Seller in Backend areas: DTOs, Entities, Controllers, Services, Migrations.
I will run a full code search for \bbuyer\b and \bseller\b across the repo and prepare a full edit plan listing exact files to change. (This is the next automated step.)

Naming & compatibility strategy (detailed)
Frontend:
Replace code-level names to user* quickly; keep runtime UI text where helpful for users.
Use thin wrapper/alias files to avoid sweeping refactors that break imports in many places (e.g., keep components/seller/ folder for one commit that re-exports from components/user/ while migrating code).
Backend:
Avoid immediate JSON key changes. Use serialization attributes to preserve outgoing/expected field names while renaming properties internally.
If DB column renames are required later, create explicit migration scripts and coordinate deployment with API client updates.
Deprecation:
Keep deprecated symbol aliases and add TODO comments and a short-lived deprecation notice in the code and PR description. Remove aliases in a later cleanup PR.
Edge cases & test matrix
Edge: mixed usage of buyer and seller in the same file (ensure both replaced or mapped).
Edge: external API clients depend on buyerId/sellerId JSON keys — do not change keys without mapping.
Edge: snapshot tests or string-based tests referencing "buyer"/"seller" need updates.
Edge: translation/i18n files may reference Buyer/Seller — search and update or leave UX strings as-is.
Tests:
Happy path: a user requests withdrawal and it gets processed (frontend + backend).
Edge case: user both buys and sells (a single account is counterparty in two roles) — ensure ledger, wallet, and withdrawals behave correctly.
Error path: backend returns "Backend server" or "not implemented" errors (page already has messaging).
Quality gates (minimal triage)
Frontend:
TypeScript typecheck (tsc or npm run build / vite), and ESLint pass.
Manual smoke: open /withdrawals in dev server and verify request and list flows.
Backend:
dotnet build (YaqeenPay.API) and run backend unit tests.
Integration:
End-to-end manual test: create an order (buyer role), deliver and release (seller role), then withdraw (user acting as seller). Validate ledger and wallet balances.
Rollout & rollback plan
Rollout:
Stage 1: Frontend rename + compatibility aliases; backend serialization mapping where required; tests green.
Stage 2: Update clients and docs; remove aliases after 1-2 releases.
Rollback:
Keep commits small and focused so they can be reverted easily if something breaks.
Avoid DB schema renames in the first pass—those are harder to rollback.
Next immediate steps (what I'll do next)
I already ran an initial search and located the frontend page and route references. Current progress:
Planning: Completed
Inventory search: In-progress (found WithdrawalsPage.tsx, index.ts, App.tsx, PHASE4_COMPLETE.md, and several other hit locations)
Next action I will take (if you want me to continue now):
Open WithdrawalsPage.tsx and rename the exported component to WithdrawalsPage (code-level change), update export default accordingly.
Update index.ts to export the new name or to re-export the canonical page from ../WithdrawalsPage while keeping a deprecated export name for safe migration.
Update App.tsx imports/routes so they consistently use WithdrawalsPage. Optionally map /seller/withdrawals → same component for a short transition period.
Run TypeScript checks and fix any resulting issues.
I will not change backend or DB fields yet — I'll prepare a separate, careful plan + mapping before editing server code.
