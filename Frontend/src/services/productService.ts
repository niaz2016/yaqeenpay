import apiService from './api';

export interface ProductImage {
  file: File;
  isPrimary: boolean;
}

export interface ProductAttribute {
  name: string;
  value: string;
}

export interface CreateProductRequest {
  name: string;
  description: string;
  price: string;
  discountPrice?: string;
  stockQuantity: string;
  categoryId: string;
  status: 'Draft' | 'Active' | 'Inactive';
  currency: string;
  attributes?: ProductAttribute[];
  images: ProductImage[];
}

export interface ProductResponse {
  id: string;
  name: string;
  description: string;
  price: number;
  currency: string;
  discountPrice?: number;
  sku: string;
  stockQuantity: number;
  status: string;
  categoryId: string;
  sellerId: string;
  createdAt: string;
  category: {
    id: string;
    name: string;
  };
  images: Array<{
    imageUrl: string;
    altText: string;
    isPrimary: boolean;
    sortOrder: number;
  }>;
  attributes: Record<string, string>;
}

class ProductService {
  // Upload a single image and return the URL
  async uploadImage(file: File): Promise<string> {
    const formData = new FormData();
    formData.append('file', file);

    try {
      // Use the existing profile upload endpoint for now
      // TODO: Create a dedicated product image upload endpoint
      const response = await apiService.post<{ url: string }>('/profile/upload-image', formData);
      
      if (!response.url || response.url.trim() === '') {
        throw new Error('Upload endpoint returned empty URL');
      }
      
      return response.url;
    } catch (error) {
      throw new Error('Failed to upload image');
    }
  }

  // Upload multiple images and return their URLs
  async uploadImages(images: ProductImage[]): Promise<Array<{ imageUrl: string; isPrimary: boolean }>> {
    try {
      const uploadPromises = images.map(async (image) => {
        const imageUrl = await this.uploadImage(image.file);
        return {
          imageUrl,
          isPrimary: image.isPrimary
        };
      });

      return await Promise.all(uploadPromises);
    } catch (error) {
      console.error('Error uploading images:', error);
      throw new Error('Failed to upload one or more images');
    }
  }

  // Create a product
  async createProduct(productData: CreateProductRequest): Promise<ProductResponse> {
    try {
      // First, upload all images if any
      let imageUrls: Array<{ imageUrl: string; isPrimary: boolean }> = [];
      
      if (productData.images && productData.images.length > 0) {
        imageUrls = await this.uploadImages(productData.images);
      }

      // Prepare the CreateProductCommand - this matches the backend's expected structure
      const createProductCommand = {
        categoryId: productData.categoryId, // This should be a GUID string
        name: productData.name,
        description: productData.description,
        shortDescription: undefined,
        price: parseFloat(productData.price),
        currency: productData.currency || 'PKR',
        discountPrice: productData.discountPrice ? parseFloat(productData.discountPrice) : undefined,
        sku: `SKU-${Date.now()}-${Math.random().toString(36).substring(2, 8).toUpperCase()}`, // Generate unique SKU
        stockQuantity: parseInt(productData.stockQuantity),
        minOrderQuantity: 1,
        maxOrderQuantity: 999999,
        weight: 0,
        weightUnit: 'kg',
        dimensions: undefined,
        brand: undefined,
        model: undefined,
        color: undefined,
        size: undefined,
        material: undefined,
        allowBackorders: false,
        tags: [],
        attributes: productData.attributes ? 
          productData.attributes.reduce((acc, attr) => {
            acc[attr.name] = attr.value;
            return acc;
          }, {} as Record<string, string>) : {},
        images: imageUrls.map((img, index) => {
          return {
            ImageUrl: img.imageUrl,
            AltText: `${productData.name} image ${index + 1}`,
            SortOrder: index,
            IsPrimary: img.isPrimary
          };
        })
      };
      const response = await apiService.post<{ id: string }>('/products', createProductCommand);
      
      return {
        id: response.id,
        name: productData.name,
        description: productData.description,
        price: parseFloat(productData.price),
        currency: productData.currency,
        discountPrice: productData.discountPrice ? parseFloat(productData.discountPrice) : undefined,
        sku: '', // Will be generated by backend
        stockQuantity: parseInt(productData.stockQuantity),
        status: productData.status,
        categoryId: productData.categoryId,
        sellerId: '', // Will be filled by backend
        createdAt: new Date().toISOString(),
        category: {
          id: productData.categoryId,
          name: '' // Will be filled by backend
        },
        images: [], // Will be populated after creation
        attributes: {} // Default empty attributes
      };
    } catch (error) {
      console.error('Error creating product:', error);
      throw error;
    }
  }

  // Get products for marketplace
  async getProducts(params?: {
    page?: number;
    pageSize?: number;
    search?: string;
    categoryId?: string;
  }): Promise<any> {
    try {
      const queryParams = new URLSearchParams();
      
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.pageSize) queryParams.append('pageSize', params.pageSize.toString());
      if (params?.search) queryParams.append('search', params.search);
      if (params?.categoryId) queryParams.append('categoryId', params.categoryId);

      const url = `/products${queryParams.toString() ? '?' + queryParams.toString() : ''}`;
      const response = await apiService.get(url);
      
      // Handle both PascalCase (C#) and camelCase (JavaScript) property names  
      const responseData = response as any;
      const items = responseData.items || responseData.Items || [];
      const totalCount = responseData.totalCount || responseData.TotalCount || 0;
      
      // Return normalized structure with lowercase property names for frontend consistency
      const normalizedResponse = {
        items: items,
        totalCount: totalCount,
        pageNumber: responseData.pageNumber || responseData.PageNumber || 1,
        pageSize: responseData.pageSize || responseData.PageSize || items.length,
        totalPages: responseData.totalPages || responseData.TotalPages || Math.ceil(totalCount / (responseData.pageSize || responseData.PageSize || 12))
      };
      return normalizedResponse;
    } catch (error: any) {
      throw error;
    }
  }

  // Get seller's products
  async getSellerProducts(params?: {
    page?: number;
    pageSize?: number;
    search?: string;
  }): Promise<any> {
    try {
      const queryParams = new URLSearchParams();
      
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.pageSize) queryParams.append('pageSize', params.pageSize.toString());
      if (params?.search) queryParams.append('search', params.search);

      const url = `/products/seller${queryParams.toString() ? '?' + queryParams.toString() : ''}`;
      return await apiService.get(url);
    } catch (error) {
      console.error('Error fetching seller products:', error);
      throw error;
    }
  }

  // Get product by ID
  async getProductById(productId: string): Promise<ProductResponse> {
    try {
      const response = await apiService.get(`/products/${productId}`);
      
      // Handle both PascalCase (C#) and camelCase (JavaScript) property names
      const data = response as any;
      return {
        id: data.id || data.Id,
        name: data.name || data.Name,
        description: data.description || data.Description,
        price: data.price || data.Price,
        currency: data.currency || data.Currency || 'PKR',
        discountPrice: data.discountPrice || data.DiscountPrice,
        sku: data.sku || data.Sku || data.SKU || '',
        stockQuantity: data.stockQuantity || data.StockQuantity,
        status: data.status || data.Status,
        categoryId: data.categoryId || data.CategoryId,
        sellerId: data.sellerId || data.SellerId,
        createdAt: data.createdAt || data.CreatedAt,
        category: {
          id: (data.category || data.Category)?.id || (data.category || data.Category)?.Id || '',
          name: (data.category || data.Category)?.name || (data.category || data.Category)?.Name || ''
        },
        images: (data.images || data.Images || []).map((img: any) => ({
          imageUrl: img.imageUrl || img.ImageUrl || '',
          altText: img.altText || img.AltText || '',
          isPrimary: img.isPrimary || img.IsPrimary || false,
          sortOrder: img.sortOrder || img.SortOrder || 0
        })),
        attributes: data.attributes || data.Attributes || {}
      };
    } catch (error) {
      console.error('Error fetching product details:', error);
      throw new Error('Failed to fetch product details');
    }
  }

  // Update existing product
  async updateProduct(productId: string, updateData: {
    name: string;
    description: string;
    price: number;
    discountPrice?: number;
    stockQuantity: number;
    categoryId: string;
    status: 'Draft' | 'Active' | 'Inactive';
    currency: string;
    imagesToDelete?: string[];
    newImages?: Array<{ file: File; isPrimary: boolean }>;
  }): Promise<ProductResponse> {
    try {
      // Upload any new images first
      let uploadedImages: Array<{ imageUrl: string; isPrimary: boolean }> = [];
      if (updateData.newImages && updateData.newImages.length > 0) {
        uploadedImages = await this.uploadImages(updateData.newImages);
      }

      // Prepare update payload expected by backend
      const updateCommand: any = {
        name: updateData.name,
        description: updateData.description,
        price: updateData.price,
        currency: updateData.currency,
        discountPrice: updateData.discountPrice,
        stockQuantity: updateData.stockQuantity,
        categoryId: updateData.categoryId,
        status: updateData.status,
      };

      // Include images to delete if provided
      if (updateData.imagesToDelete && updateData.imagesToDelete.length > 0) {
        updateCommand.imagesToDelete = updateData.imagesToDelete;
      }

      // Include newly uploaded images in backend format if any
      if (uploadedImages.length > 0) {
        updateCommand.newImages = uploadedImages.map((img, index) => ({
          ImageUrl: img.imageUrl,
          AltText: `${updateData.name} image ${index + 1}`,
          SortOrder: index,
          IsPrimary: img.isPrimary
        }));
      }

      // Send update request to API
      await apiService.put(`/products/${productId}`, updateCommand);

      // Return the freshly fetched product
      return await this.getProductById(productId);
    } catch (error) {
      console.error('Error updating product:', error);
      throw error;
    }
  }

  // Reduce stock quantity when payment is made
  async reduceStock(productId: string, quantity: number): Promise<void> {
    try {
      const response = await apiService.post<{ success: boolean; message: string; newStockQuantity: number }>(
        `/products/${productId}/reduce-stock`, 
        { quantity }
      );
      
      if (!response.success) {
        throw new Error(response.message || 'Failed to reduce stock');
      }
    } catch (error) {
      console.error('Error reducing product stock:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to reduce product stock');
    }
  }

  // Bulk reduce stock for multiple products (for orders with multiple items)
  async bulkReduceStock(items: Array<{ productId: string; quantity: number }>): Promise<void> {
    try {
      const response = await apiService.post<{ success: boolean; message: string; results: Array<{ productId: string; success: boolean; newStockQuantity?: number; error?: string }> }>(
        '/products/bulk-reduce-stock', 
        { items }
      );
      
      if (!response.success) {
        throw new Error(response.message || 'Failed to reduce stock for some items');
      }

      // Check if any individual items failed
      const failedItems = response.results?.filter(result => !result.success) || [];
      if (failedItems.length > 0) {
        const errorDetails = failedItems.map(item => `${item.productId}: ${item.error}`).join(', ');
        throw new Error(`Stock reduction failed for: ${errorDetails}`);
      }
    } catch (error) {
      console.error('Error in bulk stock reduction:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to reduce stock for multiple products');
    }
  }
}

const productService = new ProductService();
export default productService;